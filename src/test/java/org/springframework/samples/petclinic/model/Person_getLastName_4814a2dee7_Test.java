/*
Test generated by RoostGPT for test java-springboot-unit-testing using AI Type Open AI and AI Model gpt-4-1106-preview

To validate the business logic of the `getLastName` function, you would need to consider various test scenarios that focus on the behavior and constraints implied by the code and annotations. Here are some test scenarios that could be considered:

1. **Basic Retrieval Test**: 
   - Scenario: Verify that `getLastName` correctly retrieves the last name that has been set for an object.

2. **Null Value Test**:
   - Scenario: Ensure that `getLastName` can handle and return a `null` value if the last name has not been set.

3. **NotBlank Constraint Test**:
   - Scenario: Since there is a `@NotBlank` annotation, verify that the system behaves as expected when an attempt is made to persist an entity with a blank last name (e.g., an empty string or only whitespace). Note that this scenario would be more relevant to a setter method or the entity validation process rather than the `getLastName` method itself.

4. **Persistence Mapping Test**:
   - Scenario: Confirm that the `lastName` field is correctly mapped to the corresponding column in the database (as suggested by the `@Column` annotation). This would involve checking that the value retrieved by `getLastName` is the same as the value stored in the database for the entity's last name.

5. **Inheritance Mapping Test**:
   - Scenario: Given that the class appears to be a `@MappedSuperclass`, verify that subclasses inherit the `lastName` field properly and that `getLastName` functions correctly within subclasses.

6. **Immutable Field Test**:
   - Scenario: If the `lastName` field is intended to be immutable (which we cannot infer from this snippet alone but could be a business requirement), verify that there is no public setter method or any other way to modify the `lastName` after the object has been created.

7. **Concurrency Test**:
   - Scenario: If the application is multi-threaded, ensure that `getLastName` can be accessed concurrently without any race conditions or synchronization issues.

8. **Serialization Test**:
   - Scenario: If the object is meant to be serializable (e.g., for distributed applications), ensure that `getLastName` still returns the correct last name after serialization and deserialization.

9. **API Contract Test**:
   - Scenario: Verify that the `getLastName` method adheres to any defined API contracts or service level agreements, such as performance expectations.

10. **Exception Handling Test**:
    - Scenario: Although the `getLastName` method itself does not indicate any exception handling, verify that any related infrastructure (e.g., database access, entity lifecycle callbacks) handles exceptions as expected when `getLastName` is involved in a workflow.

11. **Integration Test**:
    - Scenario: Test the `getLastName` method as part of a larger workflow or use case, to ensure it integrates properly with other components of the system.

Remember that the actual implementation of these test scenarios would require additional context about how the `lastName` field is managed and how the containing class interacts with the rest of the application. Also, some scenarios would require integration testing with a database or other infrastructure rather than unit testing the method in isolation.
*/
package org.springframework.samples.petclinic.model;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

class Person_getLastName_4814a2dee7_Test {

    private Person person;

    @BeforeEach
    void setUp() {
        person = new Person();
    }

    @Test
    void testGetLastName_BasicRetrieval() {
        String expectedLastName = "Doe";
        person.setLastName(expectedLastName);
        String actualLastName = person.getLastName();
        assertEquals(expectedLastName, actualLastName);
    }

    @Test
    void testGetLastName_NullValue() {
        person.setLastName(null);
        assertNull(person.getLastName());
    }

    // Additional tests can be written for the NotBlank Constraint, Persistence Mapping,
    // Inheritance Mapping, Immutable Field, Concurrency, Serialization, API Contract,
    // Exception Handling, and Integration based on the actual use-case and system design.

}
