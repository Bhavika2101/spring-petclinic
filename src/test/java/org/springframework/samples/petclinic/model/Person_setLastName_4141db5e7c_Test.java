/*
Test generated by RoostGPT for test java-springboot-unit-testing using AI Type Open AI and AI Model gpt-4-1106-preview

To properly validate the business logic of the `setLastName` method, we should consider various test scenarios that take into account the constraints and expected behavior of the method. Here are several test scenarios:

1. **Normal Input Scenario**: 
   - Description: Set a valid last name and ensure it is correctly assigned.
   - Test Steps: Call `setLastName` with a normal last name string, like "Smith".
   - Expected Result: The last name should be set to "Smith" without any exceptions.

2. **Blank String Input Scenario**: 
   - Description: Set a blank string as the last name and check for validation constraints.
   - Test Steps: Call `setLastName` with a blank string, like "" or " ".
   - Expected Result: Since there is a `@NotBlank` constraint, an exception related to validation should be thrown.

3. **Null Input Scenario**: 
   - Description: Pass `null` as the last name and check for null handling.
   - Test Steps: Call `setLastName` with `null`.
   - Expected Result: Depending on the business logic, either the last name is set to null, or a `NullPointerException` is thrown, or a validation exception is thrown if nulls are not allowed.

4. **Long String Input Scenario**: 
   - Description: Pass an excessively long last name to test any potential length constraints.
   - Test Steps: Call `setLastName` with a very long string, possibly exceeding any defined column length in a database.
   - Expected Result: If there are length constraints, an exception should be thrown. Otherwise, the long last name should be set without issue.

5. **Special Characters Input Scenario**: 
   - Description: Use special characters in the last name to test for character validation.
   - Test Steps: Call `setLastName` with a string containing special characters, like "@Doe" or "Smith$".
   - Expected Result: Depending on whether special characters are allowed, the method either sets the last name or throws a validation exception.

6. **Injection Attack Scenario**: 
   - Description: Attempt to pass a string that could be used for SQL injection or other attacks.
   - Test Steps: Call `setLastName` with a string like "'; DROP TABLE users; --".
   - Expected Result: The method should handle the input as a normal string without executing any unintended commands. This is more of a concern for the code that interacts with the database using the last name, rather than the setter itself.

7. **Unicode Characters Input Scenario**: 
   - Description: Test the method with Unicode characters to ensure internationalization support.
   - Test Steps: Call `setLastName` with a string containing Unicode characters, like "García" or "李".
   - Expected Result: The Unicode characters should be accepted and set as the last name.

8. **Whitespace Trimming Scenario**: 
   - Description: Check how the method handles leading and trailing whitespace.
   - Test Steps: Call `setLastName` with a string with leading and trailing spaces, like "  Doe  ".
   - Expected Result: Depending on business rules, the method should either trim the whitespace or set the last name with the whitespace intact.

9. **Concurrent Access Scenario**: 
   - Description: Test the method's behavior when accessed concurrently to ensure thread-safety.
   - Test Steps: Simultaneously call `setLastName` from multiple threads.
   - Expected Result: The last name should be set correctly for each thread without data corruption or unexpected behavior.

10. **Persistence Annotation Scenario**: 
   - Description: Ensure that the last name can be persisted without violating any database constraints, assuming it is mapped to a database column.
   - Test Steps: After calling `setLastName`, persist the entity to the database.
   - Expected Result: The last name should be persisted without any database constraint violations.

These scenarios cover a range of potential issues that could arise from setting a last name on an entity. They also assume that the `setLastName` method is part of a larger entity class that interacts with a database, as suggested by the `@Column` and `@MappedSuperclass` annotations.
*/
package org.springframework.samples.petclinic.model;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

import static org.junit.jupiter.api.Assertions.*;

@SpringBootTest
class Person_setLastName_4141db5e7c_Test {

    private Person person;

    @BeforeEach
    void setUp() {
        person = new Person();
    }

    @Test
    @DisplayName("Normal Input Scenario")
    void testSetLastName_NormalInput() {
        String normalLastName = "Smith";
        person.setLastName(normalLastName);
        assertEquals(normalLastName, person.getLastName());
    }

    @Test
    @DisplayName("Blank String Input Scenario")
    void testSetLastName_BlankString() {
        Exception exception = assertThrows(IllegalArgumentException.class, () -> {
            person.setLastName("");
        });
        assertTrue(exception.getMessage().contains("must not be blank"));
    }

    @Test
    @DisplayName("Null Input Scenario")
    void testSetLastName_NullInput() {
        Exception exception = assertThrows(NullPointerException.class, () -> {
            person.setLastName(null);
        });
        assertNotNull(exception.getMessage());
    }

    @Test
    @DisplayName("Long String Input Scenario")
    void testSetLastName_LongString() {
        String longLastName = "VeryLongLastNameThatExceedsTheTypicalLengthForALastNameAndCouldPotentiallyCauseIssues";
        person.setLastName(longLastName);
        assertEquals(longLastName, person.getLastName());
    }

    @Test
    @DisplayName("Special Characters Input Scenario")
    void testSetLastName_SpecialCharacters() {
        String specialCharLastName = "Smith$";
        person.setLastName(specialCharLastName);
        assertEquals(specialCharLastName, person.getLastName());
    }

    @Test
    @DisplayName("Injection Attack Scenario")
    void testSetLastName_InjectionAttack() {
        String injectionString = "'; DROP TABLE users; --";
        person.setLastName(injectionString);
        assertEquals(injectionString, person.getLastName());
    }

    @Test
    @DisplayName("Unicode Characters Input Scenario")
    void testSetLastName_UnicodeCharacters() {
        String unicodeLastName = "García";
        person.setLastName(unicodeLastName);
        assertEquals(unicodeLastName, person.getLastName());
    }

    @Test
    @DisplayName("Whitespace Trimming Scenario")
    void testSetLastName_WhitespaceTrimming() {
        String lastNameWithWhitespace = "  Doe  ";
        person.setLastName(lastNameWithWhitespace);
        assertEquals(lastNameWithWhitespace, person.getLastName());
    }

    // TODO: Implement the Concurrent Access Scenario
    // This requires a more complex setup with threading and is not shown here.

    // TODO: Implement the Persistence Annotation Scenario
    // This requires integration with a database and is not shown here.
}
