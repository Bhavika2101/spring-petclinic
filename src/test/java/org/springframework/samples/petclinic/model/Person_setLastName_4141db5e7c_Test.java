/*
Test generated by RoostGPT for test java-springboot-unit-testing using AI Type Open AI and AI Model gpt-4-1106-preview

To properly validate the business logic of the `setLastName` method, we should consider various test scenarios that take into account the constraints and expected behavior of the method. Here are several test scenarios:

1. **Normal Input Scenario**: 
   - Description: Set a valid last name and ensure it is correctly assigned.
   - Test Steps: Call `setLastName` with a normal last name string, like "Smith".
   - Expected Result: The last name should be set to "Smith" without any exceptions.

2. **Blank String Input Scenario**:
   - Description: Set a blank string as the last name and check for validation constraints (as indicated by `@NotBlank`).
   - Test Steps: Call `setLastName` with a blank string, like "".
   - Expected Result: A ConstraintViolationException or a similar validation exception should be thrown due to the `@NotBlank` annotation.

3. **Null Input Scenario**:
   - Description: Set a null value as the last name and check for validation constraints.
   - Test Steps: Call `setLastName` with `null`.
   - Expected Result: A ConstraintViolationException or a similar validation exception should be thrown because a `null` value violates the `@NotBlank` constraint.

4. **Whitespace Input Scenario**:
   - Description: Set a last name consisting only of whitespace and check for validation constraints.
   - Test Steps: Call `setLastName` with a string containing only whitespace, like "   ".
   - Expected Result: A ConstraintViolationException or a similar validation exception should be thrown due to the `@NotBlank` annotation.

5. **Long String Input Scenario**:
   - Description: Set an excessively long last name to check if there are any length restrictions (not visible in the snippet).
   - Test Steps: Call `setLastName` with a very long string (e.g., 256 characters long).
   - Expected Result: Depending on the business rules or database constraints (e.g., `@Column(length = ...)`) that might be present but not shown in the snippet, this might either succeed or throw an exception.

6. **Special Characters Input Scenario**:
   - Description: Set a last name containing special characters to verify handling of such characters.
   - Test Steps: Call `setLastName` with a string containing special characters, like "O'Neil".
   - Expected Result: The last name should be set to "O'Neil" without any exceptions, assuming special characters are allowed.

7. **Numeric Characters Input Scenario**:
   - Description: Set a last name containing numeric characters to test the handling of numbers.
   - Test Steps: Call `setLastName` with a string containing numeric characters, like "Smith3".
   - Expected Result: Depending on the business rules, the method might accept this or throw a validation exception.

8. **Cross-Field Validation Scenario** (if applicable):
   - Description: If there are cross-field validation rules (e.g., first name and last name cannot be the same), test that these are enforced.
   - Test Steps: Assuming a `setFirstName` method exists, set both first name and last name to the same value, and check for validation constraints.
   - Expected Result: A validation exception should be thrown if such a business rule exists.

9. **Persistence Layer Integration Scenario** (if applicable):
   - Description: Test if the last name is correctly persisted in the database, respecting the `@Column` annotations.
   - Test Steps: Set a valid last name, persist the entity, and then retrieve it to check the last name.
   - Expected Result: The persisted last name should match the one set, and it should comply with any column definitions (e.g., length constraints).

10. **Concurrent Access Scenario** (if applicable):
    - Description: Test if the `setLastName` method behaves correctly under concurrent access.
    - Test Steps: Simultaneously call `setLastName` from multiple threads with different last names.
    - Expected Result: The last name of the entity should be set to one of the valid values without causing any race conditions or data corruption.

These test scenarios are designed to validate the business logic of the `setLastName` method and ensure that it behaves as expected under various input conditions and constraints.
*/
package org.springframework.samples.petclinic.model;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.springframework.test.context.junit.jupiter.SpringExtension;

import javax.validation.ConstraintViolation;
import javax.validation.ConstraintViolationException;
import javax.validation.Validation;
import javax.validation.Validator;
import java.util.Set;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertThrows;

@ExtendWith(SpringExtension.class)
public class Person_setLastName_4141db5e7c_Test {

    private Validator validator;
    private Person person;

    @BeforeEach
    public void setUp() {
        validator = Validation.buildDefaultValidatorFactory().getValidator();
        person = new Person();
    }

    @Test
    public void testSetLastName_NormalInput() {
        String lastName = "Smith";
        person.setLastName(lastName);
        assertEquals(lastName, person.getLastName(), "The last name should be set to Smith");
    }

    @Test
    public void testSetLastName_BlankStringInput() {
        String lastName = "";
        assertThrows(ConstraintViolationException.class, () -> {
            person.setLastName(lastName);
            validate(person);
        }, "A ConstraintViolationException should be thrown due to the @NotBlank annotation");
    }

    @Test
    public void testSetLastName_NullInput() {
        assertThrows(ConstraintViolationException.class, () -> {
            person.setLastName(null);
            validate(person);
        }, "A ConstraintViolationException should be thrown because a null value violates the @NotBlank constraint");
    }

    @Test
    public void testSetLastName_WhitespaceInput() {
        String lastName = "   ";
        assertThrows(ConstraintViolationException.class, () -> {
            person.setLastName(lastName);
            validate(person);
        }, "A ConstraintViolationException should be thrown due to the @NotBlank annotation");
    }

    @Test
    public void testSetLastName_LongStringInput() {
        // TODO: Set a very long string (e.g., 256 characters long)
        String lastName = "A".repeat(256);
        assertThrows(ConstraintViolationException.class, () -> {
            person.setLastName(lastName);
            validate(person);
        }, "An exception should be thrown if there are length constraints");
    }

    @Test
    public void testSetLastName_SpecialCharactersInput() {
        String lastName = "O'Neil";
        person.setLastName(lastName);
        assertEquals(lastName, person.getLastName(), "The last name should be set to O'Neil");
    }

    @Test
    public void testSetLastName_NumericCharactersInput() {
        String lastName = "Smith3";
        person.setLastName(lastName);
        assertEquals(lastName, person.getLastName(), "The last name should be set to Smith3");
    }

    // Additional test cases would be implemented here for other scenarios mentioned in the table-driven test.

    private void validate(Person person) {
        Set<ConstraintViolation<Person>> violations = validator.validate(person);
        if (!violations.isEmpty()) {
            throw new ConstraintViolationException(violations);
        }
    }
}
