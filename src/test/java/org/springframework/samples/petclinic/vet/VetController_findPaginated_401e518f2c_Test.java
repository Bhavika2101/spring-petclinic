/*
Test generated by RoostGPT for test java-springboot-unit-testing using AI Type Open AI and AI Model gpt-4-1106-preview

To validate the business logic of the `findPaginated` method, you would want to consider creating test scenarios that cover various aspects of pagination and repository interaction. Below are some test scenarios that you can use to validate the method:

1. **Happy Path Scenarios:**
   - Verify that the method returns a `Page<Vet>` object when called with a valid page number.
   - Ensure that the `Page<Vet>` object contains the correct number of items (up to the page size, which is 5).
   - Confirm that the `Page<Vet>` object has the correct page information (like total pages, current page number, total elements, etc.).

2. **Boundary Conditions:**
   - Call the method with the first page (page = 1) and verify that the pagination starts from the first record.
   - Call the method with the last page number based on the total number of records and verify that it returns the correct records, which might be less than or equal to the page size if it's the last page.
   - Call the method with a page number greater than the total number of available pages and verify the behavior (it should ideally return an empty page or handle the scenario gracefully).

3. **Invalid Input Handling:**
   - Test the method with a negative page number and verify that it handles the input correctly (potentially throwing an exception or defaulting to the first page).
   - Test the method with a non-numeric value for the page number if applicable (this might be more relevant if the method is exposed via an API endpoint).

4. **Page Size:**
   - Verify that changing the page size (if it were a parameter or configurable) correctly affects the number of records returned.

5. **Repository Interaction:**
   - Mock the `vetRepository` and verify that `findAll` is called with the correct `Pageable` object.
   - Confirm that the method handles any exceptions thrown by the `vetRepository` gracefully.

6. **Performance and Efficiency:**
   - Test the method with a large dataset to ensure that the pagination is performed efficiently and within acceptable time limits.

7. **Concurrency:**
   - Verify that the method can handle multiple concurrent requests without failing or mixing up results.

8. **Integration with UI:**
   - If this method is used in conjunction with a user interface, test that the correct data is displayed on the UI for different page requests.

9. **Sorting and Filtering:**
   - If applicable, test that the method supports sorting and filtering alongside pagination.

10. **Data Consistency:**
    - Verify that the method returns consistent results when called multiple times with the same parameters, assuming no data changes in the underlying dataset.

These test scenarios are designed to comprehensively assess the correctness, robustness, and reliability of the `findPaginated` method, ensuring that it functions as expected under various conditions.
*/
package org.springframework.samples.petclinic.vet;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;

import java.util.ArrayList;
import java.util.List;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.Mock;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageImpl;
import org.springframework.data.domain.PageRequest;

public class VetController_findPaginated_401e518f2c_Test {

	private VetController vetController;

	@Mock
	private VetRepository vetRepository;

	@BeforeEach
	public void setup() {
		vetRepository = mock(VetRepository.class);
		vetController = new VetController(vetRepository);
	}

	@Test
	public void testFindPaginated_HappyPath() {
		int page = 1;
		int pageSize = 5;
		List<Vet> vets = new ArrayList<>();
		for (int i = 0; i < pageSize; i++) {
			vets.add(new Vet());
		}
		Page<Vet> vetPage = new PageImpl<>(vets, PageRequest.of(page - 1, pageSize), vets.size());
		when(vetRepository.findAll(PageRequest.of(page - 1, pageSize))).thenReturn(vetPage);

		Page<Vet> result = vetController.findPaginated(page);

		assertEquals(pageSize, result.getContent().size());
		assertEquals(page, result.getNumber() + 1);
		assertEquals(1, result.getTotalPages());
		assertEquals(pageSize, result.getTotalElements());
	}

	@Test
	public void testFindPaginated_BoundaryCondition_LastPage() {
		int page = 2;
		int pageSize = 5;
		int totalVets = 6;
		List<Vet> vets = new ArrayList<>();
		for (int i = 0; i < totalVets - pageSize; i++) {
			vets.add(new Vet());
		}
		Page<Vet> vetPage = new PageImpl<>(vets, PageRequest.of(page - 1, pageSize), totalVets);
		when(vetRepository.findAll(PageRequest.of(page - 1, pageSize))).thenReturn(vetPage);

		Page<Vet> result = vetController.findPaginated(page);

		assertEquals(totalVets - pageSize, result.getContent().size());
		assertEquals(page, result.getNumber() + 1);
		assertEquals(2, result.getTotalPages());
		assertEquals(totalVets, result.getTotalElements());
	}

	// Additional test cases can be added to cover the remaining scenarios.

}
