/*
Test generated by RoostGPT for test java-springboot-unit-testing using AI Type Open AI and AI Model gpt-4-1106-preview

To validate the business logic of the `addPaginationModel` function, you can create the following test scenarios. These scenarios are aimed at ensuring that the function behaves correctly under various conditions:

1. **Basic Pagination Functionality:**
   - Scenario: Verify that the correct current page, total pages, total items, and list of vets are added to the model when a paginated list is provided.
   - Expected: The attributes `currentPage`, `totalPages`, `totalItems`, and `listVets` should be correctly set in the model.

2. **Empty Paginated List:**
   - Scenario: Check how the function handles an empty paginated list (no vets).
   - Expected: The model should reflect that there are no vets, with `totalItems` set to 0, `totalPages` likely set to 0 or 1, and `listVets` being an empty list.

3. **First Page of Pagination:**
   - Scenario: Validate the function when the first page is requested.
   - Expected: The `currentPage` should be set to 1 (or 0, depending on how the paging is implemented), and the model should contain the list of vets for the first page.

4. **Last Page of Pagination:**
   - Scenario: Ensure the function correctly handles the last page of pagination, which may not be fully filled with items.
   - Expected: The `currentPage` should correspond to the last page, and the `listVets` may contain fewer items than a full page.

5. **Middle Page of Pagination:**
   - Scenario: Test the function with a request for a page in the middle of the paginated list.
   - Expected: The model should correctly reflect the `currentPage` and contain the appropriate list of vets.

6. **Invalid Page Number:**
   - Scenario: Check the function's response to an invalid page number (e.g., a negative number or a number greater than the total number of pages).
   - Expected: The function should handle this gracefully, perhaps by redirecting to the first or last page, or showing an error message.

7. **Boundary Conditions:**
   - Scenario: Test the function with boundary conditions, such as the highest possible page number or zero.
   - Expected: The function should not fail and should handle these edge cases correctly.

8. **Model Integrity:**
   - Scenario: Ensure that the function does not overwrite any existing attributes in the model that are unrelated to pagination.
   - Expected: Pre-existing model attributes should remain unchanged after the function call.

9. **Page Size Consistency:**
   - Scenario: Verify that the function maintains the correct page size (number of items per page) as provided by the `paginated` object.
   - Expected: The size of the `listVets` should match the page size defined in the `paginated` object unless it's the last page which may have fewer items.

10. **Correct View Name:**
    - Scenario: Confirm that the function returns the correct view name for the application to render.
    - Expected: The function should return the view name "vets/vetList".

11. **Null Inputs:**
    - Scenario: Test how the function behaves when null values are passed for `paginated` or `model`.
    - Expected: The function should either handle null values appropriately or throw a specific exception indicating the invalid input.

12. **Pageable Consistency:**
    - Scenario: Ensure that the `currentPage` attribute matches the page number contained within the `Pageable` object of the `paginated` list.
    - Expected: The `currentPage` should be consistent with the `Pageable`'s page number.

By testing these scenarios, you can validate that the `addPaginationModel` function works correctly and robustly under various conditions, ensuring that the pagination logic in your application is reliable.
*/
package org.springframework.samples.petclinic.vet;

import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNotNull;

import java.util.ArrayList;
import java.util.List;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.springframework.data.domain.Page;
import org.springframework.ui.Model;

class VetController_addPaginationModel_53c2d9e3be_Test {

    @InjectMocks
    private VetController vetController;

    @Mock
    private VetRepository vetRepository;

    @Mock
    private Model model;

    @BeforeEach
    void setup() {
        MockitoAnnotations.openMocks(this);
        vetController = new VetController(vetRepository);
    }

    @Test
    public void testAddPaginationModelWithBasicPaginationFunctionality() {
        int page = 1;
        int totalPages = 5;
        long totalItems = 20;
        List<Vet> vetList = new ArrayList<>();
        Page<Vet> paginated = mock(Page.class);

        when(paginated.getContent()).thenReturn(vetList);
        when(paginated.getTotalPages()).thenReturn(totalPages);
        when(paginated.getTotalElements()).thenReturn(totalItems);

        String viewName = vetController.addPaginationModel(page, paginated, model);

        assertNotNull(model);
        assertEquals("vets/vetList", viewName);
    }

    @Test
    public void testAddPaginationModelWithEmptyPaginatedList() {
        int page = 1;
        int totalPages = 0;
        long totalItems = 0;
        List<Vet> vetList = new ArrayList<>();
        Page<Vet> paginated = mock(Page.class);

        when(paginated.getContent()).thenReturn(vetList);
        when(paginated.getTotalPages()).thenReturn(totalPages);
        when(paginated.getTotalElements()).thenReturn(totalItems);

        String viewName = vetController.addPaginationModel(page, paginated, model);

        assertNotNull(model);
        assertEquals("vets/vetList", viewName);
    }

    // TODO: Add more test cases for scenarios 3 to 12 as described in the task.
}
