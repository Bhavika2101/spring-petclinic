/*
Test generated by RoostGPT for test java-springboot-unit-testing using AI Type Open AI and AI Model gpt-4-1106-preview

To validate the business logic of the `addPaginationModel` function, you can create the following test scenarios. Remember that these are high-level descriptions and not the actual test code.

1. **Standard Pagination Scenario:**
   - Given a paginated list of vets with multiple pages,
   - When the `addPaginationModel` method is called with a valid page number,
   - Then the model should contain the correct current page, total pages, total items, and the list of vets for that page.

2. **First Page Scenario:**
   - Given a paginated list of vets starting at page 0,
   - When the `addPaginationModel` method is called with page number 0,
   - Then the model should reflect that the current page is the first page.

3. **Last Page Scenario:**
   - Given a paginated list of vets with multiple pages,
   - When the `addPaginationModel` method is called with the last page number,
   - Then the model should reflect that the current page is the last page and contain the remaining list of vets.

4. **Single Page Scenario:**
   - Given a paginated list of vets with only one page,
   - When the `addPaginationModel` method is called with page number 0,
   - Then the model should reflect that there is only one page and the current page is the first and last page.

5. **Empty List Scenario:**
   - Given an empty paginated list of vets,
   - When the `addPaginationModel` method is called with any page number,
   - Then the model should reflect that there are no items and the current page, total pages, and list of vets are correctly set for an empty list.

6. **Invalid Page Number Scenario:**
   - Given a paginated list of vets,
   - When the `addPaginationModel` method is called with an invalid (negative or beyond the last page) page number,
   - Then the behavior should be defined and handled appropriately (e.g., throw an exception, return the first/last page, or return an empty page).

7. **Page Size Consistency Scenario:**
   - Given a paginated list of vets with a set page size,
   - When the `addPaginationModel` method is called for a non-final page,
   - Then the model should contain the list of vets with the number of elements equal to the page size.

8. **Final Page Size Scenario:**
   - Given a paginated list of vets with a set page size,
   - When the `addPaginationModel` method is called for the final page,
   - Then the model should contain the list of vets which may be less than or equal to the page size depending on the total number of elements.

9. **Model Attribute Names Scenario:**
   - Given a paginated list of vets,
   - When the `addPaginationModel` method is called,
   - Then the model should contain attributes with exact names "currentPage", "totalPages", "totalItems", and "listVets".

10. **Return Value Scenario:**
    - Given any paginated list of vets,
    - When the `addPaginationModel` method is called,
    - Then the method should return the correct view name "vets/vetList".

Each of these scenarios represents a different aspect of the `addPaginationModel` function's behavior and will help ensure that the business logic is correctly implemented. The scenarios can be translated into actual test cases using a testing framework such as JUnit, and by mocking the `Model` and `Page<Vet>` instances as needed.
*/
package org.springframework.samples.petclinic.vet;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.springframework.data.domain.Page;
import org.springframework.ui.Model;
import static org.mockito.Mockito.*;
import static org.junit.jupiter.api.Assertions.*;

class VetController_addPaginationModel_53c2d9e3be_Test {

	private VetController vetController;

	@Mock
	private VetRepository vetRepository;

	@Mock
	private Model model;

	@Mock
	private Page<Vet> page;

	@BeforeEach
	void setUp() {
		MockitoAnnotations.openMocks(this);
		vetController = new VetController(vetRepository);
	}

	@Test
    void testAddPaginationModel_StandardScenario() {
        when(page.getTotalPages()).thenReturn(3);
        when(page.getTotalElements()).thenReturn(15L);
        when(page.getContent()).thenReturn(mock(List.class));

        String viewName = vetController.addPaginationModel(2, page, model);

        verify(model).addAttribute("currentPage", 2);
        verify(model).addAttribute("totalPages", 3);
        verify(model).addAttribute("totalItems", 15L);
        verify(model).addAttribute(eq("listVets"), any(List.class));
        assertEquals("vets/vetList", viewName);
    }

	@Test
    void testAddPaginationModel_EmptyListScenario() {
        when(page.getTotalPages()).thenReturn(0);
        when(page.getTotalElements()).thenReturn(0L);
        when(page.getContent()).thenReturn(mock(List.class));

        String viewName = vetController.addPaginationModel(1, page, model);

        verify(model).addAttribute("currentPage", 1);
        verify(model).addAttribute("totalPages", 0);
        verify(model).addAttribute("totalItems", 0L);
        verify(model).addAttribute(eq("listVets"), any(List.class));
        assertEquals("vets/vetList", viewName);
    }

}
