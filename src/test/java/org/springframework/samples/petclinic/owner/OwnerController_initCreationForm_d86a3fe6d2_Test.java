/*
Test generated by RoostGPT for test pom-test using AI Type Open AI and AI Model gpt-4

1. Scenario: Initialize Creation Form with Empty Model.
   - Description: The function should initialize an 'owner' object and put it in the provided model. The returned view should be 'VIEWS_OWNER_CREATE_OR_UPDATE_FORM'.
  
2. Scenario: Initialize Creation Form with Non-Empty Model.
   - Description: The function should initialize an 'owner' object and put it in the provided model, even if the model already contains other data. The existing data in the model should not be affected.

3. Scenario: Initialize Creation Form with Null Model.
   - Description: The function should handle a null model input gracefully. It should not throw a null pointer exception or any other unexpected errors.

4. Scenario: Initialize Creation Form with Model Containing Existing 'owner' Key.
   - Description: The function should overwrite the existing 'owner' key in the model with the new 'owner' object. The original 'owner' object in the model should not be present after the function call.

5. Scenario: Initialize Creation Form with Model Containing 'owner' Key of Different Type.
   - Description: The function should handle a model where the 'owner' key is associated with a value of a different type. The function should overwrite the 'owner' key with the new 'owner' object.

6. Scenario: Initialize Creation Form with Model That is Not Modifiable.
   - Description: The function should handle a model that does not allow modifications (e.g., an unmodifiable map). The function should not throw unexpected exceptions.

7. Scenario: Verify Return Value.
   - Description: The function should always return 'VIEWS_OWNER_CREATE_OR_UPDATE_FORM', regardless of the input model.

8. Scenario: Verify 'owner' Object State.
   - Description: The function should initialize a new 'owner' object. This object should be in its initial state (e.g., all fields are null or their default values).

9. Scenario: Verify 'owner' Object in Model.
   - Description: The function should put the 'owner' object in the model. After the function call, the model should contain an 'owner' key, and the associated value should be the 'owner' object created by the function.

10. Scenario: Concurrent Access to 'initCreationForm' Function.
    - Description: The function should handle concurrent access correctly. If multiple threads call this function at the same time with different models, each model should contain its own 'owner' object, and these objects should not interfere with each other.
*/
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.samples.petclinic.owner.Owner;
import org.springframework.samples.petclinic.owner.OwnerController;
import org.springframework.samples.petclinic.owner.OwnerRepository;

import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNotNull;

@ExtendWith(MockitoExtension.class)
public class OwnerController_initCreationForm_d86a3fe6d2_Test {

    @Mock
    private OwnerRepository owners;

    @InjectMocks
    private OwnerController ownerController;

    private Map<String, Object> model;

    @BeforeEach
    public void setUp() {
        model = new HashMap<>();
    }

    @Test
    public void testInitCreationFormWithEmptyModel() {
        String view = ownerController.initCreationForm(model);
        assertEquals("owners/createOrUpdateOwnerForm", view);
        assertNotNull(model.get("owner"));
    }

    @Test
    public void testInitCreationFormWithNonEmptyModel() {
        model.put("key", "value");
        String view = ownerController.initCreationForm(model);
        assertEquals("owners/createOrUpdateOwnerForm", view);
        assertNotNull(model.get("owner"));
        assertEquals("value", model.get("key"));
    }

    @Test
    public void testInitCreationFormWithNullModel() {
        String view = ownerController.initCreationForm(null);
        assertEquals("owners/createOrUpdateOwnerForm", view);
    }

    @Test
    public void testInitCreationFormWithExistingOwnerKey() {
        model.put("owner", new Owner());
        String view = ownerController.initCreationForm(model);
        assertEquals("owners/createOrUpdateOwnerForm", view);
        assertNotNull(model.get("owner"));
    }

    @Test
    public void testInitCreationFormWithOwnerKeyOfDifferentType() {
        model.put("owner", "string");
        String view = ownerController.initCreationForm(model);
        assertEquals("owners/createOrUpdateOwnerForm", view);
        assertNotNull(model.get("owner"));
    }

    @Test
    public void testInitCreationFormWithUnmodifiableMap() {
        model = new ConcurrentHashMap<>();
        String view = ownerController.initCreationForm(model);
        assertEquals("owners/createOrUpdateOwnerForm", view);
        assertNotNull(model.get("owner"));
    }

    @Test
    public void testReturnValue() {
        String view = ownerController.initCreationForm(model);
        assertEquals("owners/createOrUpdateOwnerForm", view);
    }

    @Test
    public void testOwnerObjectState() {
        ownerController.initCreationForm(model);
        Owner owner = (Owner) model.get("owner");
        assertNotNull(owner);
        assertEquals(new Owner(), owner);
    }

    @Test
    public void testOwnerObjectInModel() {
        ownerController.initCreationForm(model);
        assertNotNull(model.get("owner"));
        assertEquals(Owner.class, model.get("owner").getClass());
    }

    @Test
    public void testConcurrentAccess() throws InterruptedException {
        Thread thread1 = new Thread(() -> ownerController.initCreationForm(new HashMap<>()));
        Thread thread2 = new Thread(() -> ownerController.initCreationForm(new HashMap<>()));
        thread1.start();
        thread2.start();
        thread1.join();
        thread2.join();
    }
}
