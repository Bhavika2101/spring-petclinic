/*
Test generated by RoostGPT for test java-springboot-unit-testing using AI Type Open AI and AI Model gpt-4-1106-preview

To validate the business logic of the `addPaginationModel` function without writing test code, you would consider the following test scenarios:

1. **Happy Path Scenarios:**
    - **Valid Page Number:** Given a valid page number, the function should add the correct attributes to the model (currentPage, totalPages, totalItems, listOwners) and return the correct view name "owners/ownersList".
    - **First Page Request:** When the first page is requested, check if `currentPage` is correctly set to 1 (or 0 if the pagination is zero-based).
    - **Last Page Request:** When the last page is requested, ensure that `currentPage` matches the last page number and that the list of owners corresponds to the final page's content.

2. **Boundary Conditions:**
    - **Page Number at Boundary:** Test with the page number at the boundary conditions (e.g., first page and last page) to ensure correct model attributes are set.
    - **Empty Page:** If the paginated content is empty, the function should still set the correct model attributes with zero total items and pages, and an empty list for `listOwners`.

3. **Error Scenarios:**
    - **Negative Page Number:** Pass a negative page number and expect the function to handle it gracefully, possibly by redirecting to a valid page or showing an error message.
    - **Page Number Exceeding Total Pages:** Input a page number greater than the total number of pages and expect the function to handle the scenario appropriately (e.g., redirect to the last page or show an error message).
    - **Null Paginated Content:** Pass a null `Page<Owner>` object and ensure that the function either throws an appropriate exception or handles the null case correctly.

4. **Data Integrity:**
    - **Consistency Between TotalItems and List Size:** Ensure that the `totalItems` attribute matches the size of the `listOwners` when paginated content is not empty.
    - **Correct Owners List:** Verify that the `listOwners` attribute contains the correct subset of owners for the requested page.

5. **Model Attributes Verification:**
    - **Attributes Presence:** Confirm that all necessary attributes (`currentPage`, `totalPages`, `totalItems`, `listOwners`) are indeed added to the model.
    - **Attributes Type:** Check that the types of the model attributes match what is expected (e.g., `currentPage` and `totalPages` should be integers).

6. **Integration with View:**
    - **View Resolution:** Ensure that the returned view name "owners/ownersList" is correctly resolved by the view resolver and that the model attributes are accessible within the view.

7. **Pageable Handling:**
    - **Different Page Sizes:** Test with different page sizes to ensure that pagination is working correctly, and the correct number of owners is displayed per page.
    - **Sort Order:** If applicable, test that the sort order is maintained in the `listOwners` according to the `Pageable` configuration.

8. **Performance Considerations:**
    - **Large Data Set:** Test the method with a large data set to ensure that the application performs well and the correct pagination is applied without significant delays.

By considering these test scenarios, you would be able to validate the business logic of the `addPaginationModel` function comprehensively.
*/
package org.springframework.samples.petclinic.owner;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.data.domain.Page;
import org.springframework.ui.Model;
import java.util.ArrayList;
import java.util.List;
import static org.mockito.Mockito.*;
import static org.junit.jupiter.api.Assertions.*;

@ExtendWith(MockitoExtension.class)
public class OwnerController_addPaginationModel_996bca2e5f_Test {

    private OwnerController ownerController;

    @Mock
    private OwnerRepository ownerRepository;

    @Mock
    private Model model;

    @Mock
    private Page<Owner> paginated;

    @BeforeEach
    void setUp() {
        ownerController = new OwnerController(ownerRepository);
    }

    @Test
    void testAddPaginationModel_ValidPage() {
        int page = 2;
        int totalPages = 5;
        long totalItems = 20;
        List<Owner> ownerList = new ArrayList<>();
        ownerList.add(new Owner());
        ownerList.add(new Owner());

        when(paginated.getTotalPages()).thenReturn(totalPages);
        when(paginated.getTotalElements()).thenReturn(totalItems);
        when(paginated.getContent()).thenReturn(ownerList);

        String viewName = ownerController.addPaginationModel(page, model, paginated);

        verify(model).addAttribute("currentPage", page);
        verify(model).addAttribute("totalPages", totalPages);
        verify(model).addAttribute("totalItems", totalItems);
        verify(model).addAttribute("listOwners", ownerList);
        assertEquals("owners/ownersList", viewName);
    }

    @Test
    void testAddPaginationModel_EmptyPage() {
        int page = 1;
        when(paginated.getTotalPages()).thenReturn(0);
        when(paginated.getTotalElements()).thenReturn(0L);
        when(paginated.getContent()).thenReturn(new ArrayList<>());

        String viewName = ownerController.addPaginationModel(page, model, paginated);

        verify(model).addAttribute("currentPage", page);
        verify(model).addAttribute("totalPages", 0);
        verify(model).addAttribute("totalItems", 0L);
        verify(model).addAttribute("listOwners", new ArrayList<Owner>());
        assertEquals("owners/ownersList", viewName);
    }
}
