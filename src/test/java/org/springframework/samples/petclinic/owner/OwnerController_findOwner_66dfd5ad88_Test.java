/*
Test generated by RoostGPT for test java-springboot-unit-testing using AI Type Open AI and AI Model gpt-4-1106-preview

Given the provided code snippet, the `findOwner` method is designed to find an `Owner` by its `ownerId`. If the `ownerId` is not provided (i.e., it's `null`), it returns a new `Owner` object. The method appears to be part of a larger controller class that interacts with a data source (e.g., a database) through a service or repository named `owners`.

Here are some test scenarios to validate the business logic of the `findOwner` method:

1. **Owner ID Provided and Exists**
   - Given a valid `ownerId` that exists in the data source, when the `findOwner` method is called, then it should return the corresponding `Owner` object.

2. **Owner ID Provided but Does Not Exist**
   - Given a valid `ownerId` that does not exist in the data source, when the `findOwner` method is called, then it should return `null` or throw an appropriate exception, depending on how the `findById` method is implemented.

3. **Owner ID is Null**
   - Given that `ownerId` is `null`, when the `findOwner` method is called, then it should return a new `Owner` object.

4. **Owner ID is Negative**
   - Given a negative `ownerId`, when the `findOwner` method is called, then it should either return `null`, throw an exception, or handle the case as per the business logic defined for invalid IDs.

5. **Owner ID is Zero**
   - Given an `ownerId` of zero, when the `findOwner` method is called, then the behavior should be consistent with the business rules for handling non-positive IDs (similar to a negative ID scenario).

6. **Data Source/Repository Behavior**
   - Given that the `owners.findById` method might throw an exception (e.g., for database connectivity issues), when the `findOwner` method is called, then the exception should be handled gracefully.

7. **Owner ID is of Invalid Type**
   - Given an `ownerId` of a type that is not an integer (e.g., a string or a character), when the `findOwner` method is called, then it should result in a type mismatch error or be handled according to the application's validation logic.

8. **Concurrency and Thread Safety**
   - Given multiple concurrent requests with different `ownerId` values, when the `findOwner` method is called, then it should consistently return the correct `Owner` objects without any race conditions or data integrity issues.

9. **Owner ID is at the Boundary of Integer Range**
   - Given an `ownerId` at the boundary of the integer range (e.g., `Integer.MAX_VALUE` or `Integer.MIN_VALUE`), when the `findOwner` method is called, then it should be handled as per the business logic for extreme boundary values.

10. **Performance Under Load**
    - Given a high volume of requests to the `findOwner` method, when the method is called, then it should perform within acceptable response time limits and not cause any performance degradation.

Each of these scenarios would need to be converted into actual test cases with specific input data and expected results to validate that the `findOwner` method behaves correctly under different conditions.
*/
package org.springframework.samples.petclinic.owner;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import static org.mockito.Mockito.when;
import static org.mockito.ArgumentMatchers.anyInt;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertNull;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertThrows;

@ExtendWith(MockitoExtension.class)
public class OwnerController_findOwner_66dfd5ad88_Test {

	@Mock
	private OwnerRepository owners;

	@InjectMocks
	private OwnerController ownerController;

	@BeforeEach
	void setup() {
		ownerController = new OwnerController(owners);
	}

	@Test
	public void testFindOwner_WithExistingOwnerId() {
		Owner expectedOwner = new Owner();
		when(owners.findById(anyInt())).thenReturn(expectedOwner);

		Owner actualOwner = ownerController.findOwner(1);

		assertNotNull(actualOwner);
		assertEquals(expectedOwner, actualOwner);
	}

	@Test
    public void testFindOwner_WithNonExistingOwnerId() {
        when(owners.findById(anyInt())).thenReturn(null);

        Owner actualOwner = ownerController.findOwner(999);

        assertNull(actualOwner);
    }

	@Test
	public void testFindOwner_WithNullOwnerId() {
		Owner actualOwner = ownerController.findOwner(null);

		assertNotNull(actualOwner);
	}

	@Test
    public void testFindOwner_WithNegativeOwnerId() {
        when(owners.findById(anyInt())).thenReturn(null);

        Owner actualOwner = ownerController.findOwner(-1);

        assertNull(actualOwner);
    }

	@Test
    public void testFindOwner_WithZeroOwnerId() {
        when(owners.findById(anyInt())).thenReturn(null);

        Owner actualOwner = ownerController.findOwner(0);

        assertNull(actualOwner);
    }

	@Test
    public void testFindOwner_DataSourceThrowsException() {
        when(owners.findById(anyInt())).thenThrow(new RuntimeException("Database connectivity issue"));

        assertThrows(RuntimeException.class, () -> ownerController.findOwner(1));
    }

	@Test
	public void testFindOwner_WithMaxIntegerOwnerId() {
		Owner expectedOwner = new Owner();
		when(owners.findById(Integer.MAX_VALUE)).thenReturn(expectedOwner);

		Owner actualOwner = ownerController.findOwner(Integer.MAX_VALUE);

		assertNotNull(actualOwner);
		assertEquals(expectedOwner, actualOwner);
	}

	@Test
    public void testFindOwner_WithMinIntegerOwnerId() {
        when(owners.findById(Integer.MIN_VALUE)).thenReturn(null);

        Owner actualOwner = ownerController.findOwner(Integer.MIN_VALUE);

        assertNull(actualOwner);
    }

}
