/*
Test generated by RoostGPT for test java-springboot-unit-testing using AI Type Open AI and AI Model gpt-4-1106-preview

To validate the business logic of the `findPaginatedForOwnersLastName` method, here are several test scenarios that can be considered:

1. **Valid Last Name with Results**: 
   - **Given**: A valid `lastname` that exists in the database.
   - **When**: The method is called with a page number that has results.
   - **Then**: The returned `Page<Owner>` should contain the expected number of owners with the given last name, not exceeding the page size.

2. **Valid Last Name with No Results**:
   - **Given**: A valid `lastname` that does not exist in the database.
   - **When**: The method is called with any page number.
   - **Then**: The returned `Page<Owner>` should be empty with a total of zero elements.

3. **Invalid Last Name**:
   - **Given**: An invalid `lastname` (e.g., special characters, numbers, etc.).
   - **When**: The method is called.
   - **Then**: Depending on the database and search implementation, the method should either return an empty `Page<Owner>` or throw an exception.

4. **Boundary Case for Page Number (First Page)**:
   - **Given**: A valid `lastname`.
   - **When**: The method is called with page number 1.
   - **Then**: The returned `Page<Owner>` should contain the first set of owners (up to the page size limit).

5. **Boundary Case for Page Number (Last Page)**:
   - **Given**: A valid `lastname`.
   - **When**: The method is called with the last possible page number based on the total number of results.
   - **Then**: The returned `Page<Owner>` should contain the last set of owners, which may be less than or equal to the page size.

6. **Page Number Exceeding Total Pages**:
   - **Given**: A valid `lastname`.
   - **When**: The method is called with a page number that exceeds the total number of available pages.
   - **Then**: The returned `Page<Owner>` should be empty, indicating that there are no results for that page.

7. **Page Size Consistency**:
   - **Given**: A valid `lastname` with enough entries to span multiple pages.
   - **When**: The method is called for different page numbers within the valid range.
   - **Then**: Each returned `Page<Owner>` (except possibly the last one) should contain exactly the number of elements specified by the page size.

8. **Negative Page Number**:
   - **Given**: A valid `lastname`.
   - **When**: The method is called with a negative page number.
   - **Then**: The method should either return the first page as if page number 1 was provided or throw an exception.

9. **Zero Page Number**:
   - **Given**: A valid `lastname`.
   - **When**: The method is called with page number 0.
   - **Then**: Depending on the implementation, the method should either treat this as the first page and return results accordingly or throw an exception.

10. **Null Last Name**:
    - **Given**: `lastname` is null.
    - **When**: The method is called.
    - **Then**: The method should either return all owners disregarding the last name filter or throw an exception.

11. **Empty Last Name**:
    - **Given**: `lastname` is an empty string.
    - **When**: The method is called.
    - **Then**: The method should either return all owners disregarding the last name filter or return an empty `Page<Owner>` if the empty string is considered a valid search query with no results.

12. **Concurrent Modifications**:
    - **Given**: A valid `lastname` and concurrent modifications to the underlying data store (e.g., new owners are added or existing ones are deleted).
    - **When**: The method is called before and after the modification.
    - **Then**: The results should reflect the current state of the database at the time of the method call.

Each of these scenarios would help ensure that the `findPaginatedForOwnersLastName` function behaves correctly under various conditions and edge cases.
*/
package org.springframework.samples.petclinic.owner;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageImpl;
import org.springframework.data.domain.PageRequest;

import java.util.ArrayList;
import java.util.List;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.mockito.Mockito.when;

@ExtendWith(MockitoExtension.class)
public class OwnerController_findPaginatedForOwnersLastName_5e7208e66f_Test {

    @Mock
    private OwnerRepository owners;

    @InjectMocks
    private OwnerController ownerController;

    private static final int PAGE_SIZE = 5;

    @BeforeEach
    public void setUp() {
        // TODO: Set up any shared resources or mock responses here
    }

    @Test
    public void whenValidLastNameWithResults_thenCorrectOwnersReturned() {
        int page = 1;
        String lastname = "Smith";
        List<Owner> ownerList = createOwnerListWithLastName(lastname, PAGE_SIZE);
        Page<Owner> ownerPage = new PageImpl<>(ownerList, PageRequest.of(page - 1, PAGE_SIZE), ownerList.size());

        when(owners.findByLastName(lastname, PageRequest.of(page - 1, PAGE_SIZE))).thenReturn(ownerPage);

        Page<Owner> result = ownerController.findPaginatedForOwnersLastName(page, lastname);

        assertEquals(ownerPage.getTotalElements(), result.getTotalElements());
        assertEquals(ownerList, result.getContent());
    }

    @Test
    public void whenValidLastNameWithNoResults_thenEmptyPageReturned() {
        int page = 1;
        String lastname = "DoesNotExist";
        Page<Owner> emptyPage = new PageImpl<>(new ArrayList<>(), PageRequest.of(page - 1, PAGE_SIZE), 0);

        when(owners.findByLastName(lastname, PageRequest.of(page - 1, PAGE_SIZE))).thenReturn(emptyPage);

        Page<Owner> result = ownerController.findPaginatedForOwnersLastName(page, lastname);

        assertEquals(0, result.getTotalElements());
        assertEquals(emptyPage, result);
    }

    // TODO: Add more tests for each scenario described in the test case scenarios table

    private List<Owner> createOwnerListWithLastName(String lastname, int count) {
        List<Owner> ownerList = new ArrayList<>();
        for (int i = 0; i < count; i++) {
            Owner owner = new Owner();
            owner.setLastName(lastname);
            ownerList.add(owner);
        }
        return ownerList;
    }
}
