/*
Test generated by RoostGPT for test java-springboot-unit-testing using AI Type Open AI and AI Model gpt-4-1106-preview

To validate the business logic of the `findPaginatedForOwnersLastName` method, the following test scenarios should be considered:

1. **Valid Last Name with Results**: 
   - Given a valid last name and a page number, when the method is called, it should return a Page object with a list of Owner objects whose last name matches the input.
   - The Page object should contain Owners distributed correctly across pages according to the specified page size (5 in this case).

2. **Valid Last Name with No Results**: 
   - Given a valid last name that does not match any records and a page number, when the method is called, it should return an empty Page object.

3. **Invalid Page Number**: 
   - Given a valid last name and an invalid page number (e.g., negative number, zero, or a page number that exceeds the total number of pages), when the method is called, it should handle the scenario appropriately (e.g., throw an exception, return the first page, or return an empty Page object).

4. **Null or Empty Last Name**: 
   - Given a null or empty last name and a valid page number, when the method is called, the behavior should be defined and handled accordingly (e.g., return all owners paginated, throw an exception, or return an empty Page object).

5. **Boundary Conditions**: 
   - Test the method with the last name that matches exactly one owner to ensure that the pagination still works with a single result.
   - Test the method with the last name that matches a number of owners that is exactly the page size (5 in this case) and slightly more than the page size (e.g., 6) to ensure the pagination logic handles page boundaries correctly.

6. **Case Sensitivity**: 
   - Verify whether the search for the last name is case-sensitive or not, and ensure that the method behavior is consistent with the expected behavior.

7. **Special Characters in Last Name**: 
   - Test the method with last names that contain special characters or white spaces to ensure that the search mechanism is robust and can handle different types of input.

8. **Performance under Load**: 
   - Ensure that the method performs efficiently when dealing with a large dataset and the response time is within acceptable limits.

9. **Concurrent Access**: 
   - Test how the method behaves under concurrent access to ensure that the pagination results remain consistent and there are no race conditions or other concurrency-related issues.

10. **Sorting**: 
   - If the underlying `findByLastName` method supports sorting, test whether the paginated results are returned in the expected sorted order.

11. **Integration with Database**: 
   - Ensure that the method correctly interacts with the database and the `owners.findByLastName` repository method, and that the results are consistent with the data in the database.

12. **Exception Handling**: 
   - Verify that the method handles any exceptions that might be thrown by the `owners.findByLastName` repository method, such as database connectivity issues, and that appropriate error handling or user feedback is provided.

Each of these scenarios would need to be converted into actual test cases with specific inputs to validate the behavior of the `findPaginatedForOwnersLastName` method.
*/
package org.springframework.samples.petclinic.owner;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageImpl;
import org.springframework.data.domain.PageRequest;
import java.util.Collections;
import java.util.List;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
public class OwnerController_findPaginatedForOwnersLastName_5e7208e66f_Test {

    @Mock
    private OwnerRepository owners;

    @InjectMocks
    private OwnerController ownerController;

    private static final int PAGE_SIZE = 5;

    @BeforeEach
    void setUp() {
        // TODO: Add any additional setup if required
    }

    @Test
    void validLastNameWithResults() {
        int page = 1;
        String lastName = "Smith";
        List<Owner> ownerList = List.of(new Owner(), new Owner()); // Assuming two owners with last name 'Smith'
        Page<Owner> expectedPage = new PageImpl<>(ownerList, PageRequest.of(page - 1, PAGE_SIZE), ownerList.size());
        when(owners.findByLastName(lastName, PageRequest.of(page - 1, PAGE_SIZE))).thenReturn(expectedPage);

        Page<Owner> actualPage = ownerController.findPaginatedForOwnersLastName(page, lastName);

        assertEquals(expectedPage, actualPage);
        verify(owners, times(1)).findByLastName(lastName, PageRequest.of(page - 1, PAGE_SIZE));
    }

    @Test
    void validLastNameWithNoResults() {
        int page = 1;
        String lastName = "Nonexistent";
        Page<Owner> expectedPage = new PageImpl<>(Collections.emptyList(), PageRequest.of(page - 1, PAGE_SIZE), 0);
        when(owners.findByLastName(lastName, PageRequest.of(page - 1, PAGE_SIZE))).thenReturn(expectedPage);

        Page<Owner> actualPage = ownerController.findPaginatedForOwnersLastName(page, lastName);

        assertTrue(actualPage.isEmpty());
        verify(owners, times(1)).findByLastName(lastName, PageRequest.of(page - 1, PAGE_SIZE));
    }

    @Test
    void invalidPageNumber() {
        int page = -1; // Invalid page number
        String lastName = "Smith";
        assertThrows(IllegalArgumentException.class, () -> ownerController.findPaginatedForOwnersLastName(page, lastName));
    }

    @Test
    void nullOrEmptyLastName() {
        int page = 1;
        String lastName = ""; // Empty last name should retrieve all owners
        Page<Owner> expectedPage = new PageImpl<>(Collections.emptyList(), PageRequest.of(page - 1, PAGE_SIZE), 0);
        when(owners.findByLastName(lastName, PageRequest.of(page - 1, PAGE_SIZE))).thenReturn(expectedPage);

        Page<Owner> actualPage = ownerController.findPaginatedForOwnersLastName(page, lastName);

        assertNotNull(actualPage);
        assertTrue(actualPage.isEmpty());
        verify(owners, times(1)).findByLastName(lastName, PageRequest.of(page - 1, PAGE_SIZE));
    }

    @Test
    void boundaryConditions_singleResult() {
        int page = 1;
        String lastName = "UniqueLastName";
        List<Owner> ownerList = List.of(new Owner()); // Assuming one owner with a unique last name
        Page<Owner> expectedPage = new PageImpl<>(ownerList, PageRequest.of(page - 1, PAGE_SIZE), ownerList.size());
        when(owners.findByLastName(lastName, PageRequest.of(page - 1, PAGE_SIZE))).thenReturn(expectedPage);

        Page<Owner> actualPage = ownerController.findPaginatedForOwnersLastName(page, lastName);

        assertEquals(1, actualPage.getTotalElements());
        verify(owners, times(1)).findByLastName(lastName, PageRequest.of(page - 1, PAGE_SIZE));
    }

    @Test
    void boundaryConditions_exactPageSize() {
        int page = 1;
        String lastName = "CommonLastName";
        List<Owner> ownerList = Collections.nCopies(PAGE_SIZE, new Owner()); // Assuming 5 owners with a common last name
        Page<Owner> expectedPage = new PageImpl<>(ownerList, PageRequest.of(page - 1, PAGE_SIZE), ownerList.size());
        when(owners.findByLastName(lastName, PageRequest.of(page - 1, PAGE_SIZE))).thenReturn(expectedPage);

        Page<Owner> actualPage = ownerController.findPaginatedForOwnersLastName(page, lastName);

        assertEquals(PAGE_SIZE, actualPage.getContent().size());
        verify(owners, times(1)).findByLastName(lastName, PageRequest.of(page - 1, PAGE_SIZE));
    }

    // Additional test cases can be written for other scenarios such as case sensitivity, special characters, performance under load, concurrent access, sorting, integration with database, and exception handling.
}
