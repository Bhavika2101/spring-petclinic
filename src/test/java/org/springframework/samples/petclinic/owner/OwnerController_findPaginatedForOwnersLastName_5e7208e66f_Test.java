/*
Test generated by RoostGPT for test java-springboot-unit-testing using AI Type Open AI and AI Model gpt-4-1106-preview

To validate the business logic of the `findPaginatedForOwnersLastName` method, the following test scenarios should be considered:

1. **Valid Last Name with Results**: 
   - Given a valid last name and a page number,
   - When the method is called,
   - Then it should return a `Page<Owner>` object containing owners with the specified last name,
   - And the number of records should not exceed the page size (5 in this case),
   - And the page information (number, size) should match the requested values.

2. **Valid Last Name with No Results**: 
   - Given a valid last name that does not exist in the database and a page number,
   - When the method is called,
   - Then it should return an empty `Page<Owner>` object,
   - And the total number of pages should be zero.

3. **Invalid Last Name**: 
   - Given an invalid last name (e.g., null, empty string, or special characters) and a page number,
   - When the method is called,
   - Then the behavior depends on the implementation of `owners.findByLastName`. It might throw an exception, or it might treat it as a search for non-existing last names and return an empty page.

4. **Boundary Page Number (First and Last Page)**:
   - Given a valid last name,
   - When the method is called with the first page number (1),
   - Then it should return the first page of results,
   - And when called with the last possible page number based on data size,
   - Then it should return the last page of results.

5. **Invalid Page Number (Zero, Negative, Over Max)**:
   - Given a valid last name,
   - When the method is called with an invalid page number such as 0, a negative number, or a number greater than the total number of pages,
   - Then it should handle the invalid page number gracefully, which could be either by throwing an exception or defaulting to a valid page (e.g., the first or last page).

6. **Page Size Consistency Across Pages**:
   - Given a last name with more than 5 owners,
   - When the method is called for different pages,
   - Then each page (except possibly the last) should contain exactly 5 owners.

7. **Sorting Order**:
   - If the underlying repository method `owners.findByLastName` is supposed to sort the results,
   - When the method is called,
   - Then the returned owners should be sorted as specified by the repository method.

8. **Total Elements and Total Pages**:
   - Given a last name with a known number of matching owners,
   - When the method is called,
   - Then the `Page<Owner>` object should provide the correct total number of elements and total pages.

9. **Search with Substring of Last Name**:
   - Depending on business requirements, if searching with a substring is allowed,
   - Given a substring of a last name that matches multiple owners and a page number,
   - When the method is called,
   - Then it should return a page with the owners whose last names contain the substring.

10. **Concurrency Handling**:
    - Given multiple concurrent requests for the same last name and page number,
    - When the method is called simultaneously,
    - Then it should ensure thread safety and return consistent results without any data corruption or loss.

Each of these test scenarios would need to be implemented in a test suite to fully validate the `findPaginatedForOwnersLastName` method. The actual implementation of the tests would depend on the testing framework being used, such as JUnit or TestNG, and might involve mocking the `owners` repository to control the behavior of the `findByLastName` method.
*/
package org.springframework.samples.petclinic.owner;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageImpl;
import org.springframework.data.domain.PageRequest;

import java.util.ArrayList;
import java.util.List;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
public class OwnerController_findPaginatedForOwnersLastName_5e7208e66f_Test {

    @Mock
    private OwnerRepository owners;

    @InjectMocks
    private OwnerController ownerController;

    private static final int PAGE_SIZE = 5;

    @BeforeEach
    void setUp() {
        ownerController = new OwnerController(owners);
    }

    @Test
    void testFindPaginatedForOwnersLastName_ValidLastNameWithResults() {
        int page = 1;
        String lastName = "Smith";
        List<Owner> ownerList = new ArrayList<>();
        for (int i = 0; i < PAGE_SIZE; i++) {
            ownerList.add(new Owner());
        }
        Page<Owner> expectedPage = new PageImpl<>(ownerList, PageRequest.of(page - 1, PAGE_SIZE), ownerList.size());

        when(owners.findByLastName(lastName, PageRequest.of(page - 1, PAGE_SIZE))).thenReturn(expectedPage);

        Page<Owner> actualPage = ownerController.findPaginatedForOwnersLastName(page, lastName);

        assertNotNull(actualPage);
        assertEquals(PAGE_SIZE, actualPage.getContent().size());
        assertEquals(page, actualPage.getNumber() + 1);
        assertEquals(expectedPage, actualPage);

        verify(owners, times(1)).findByLastName(lastName, PageRequest.of(page - 1, PAGE_SIZE));
    }

    @Test
    void testFindPaginatedForOwnersLastName_ValidLastNameWithNoResults() {
        int page = 1;
        String lastName = "Nonexistent";
        Page<Owner> expectedPage = new PageImpl<>(new ArrayList<>(), PageRequest.of(page - 1, PAGE_SIZE), 0);

        when(owners.findByLastName(lastName, PageRequest.of(page - 1, PAGE_SIZE))).thenReturn(expectedPage);

        Page<Owner> actualPage = ownerController.findPaginatedForOwnersLastName(page, lastName);

        assertNotNull(actualPage);
        assertTrue(actualPage.isEmpty());
        assertEquals(0, actualPage.getTotalPages());

        verify(owners, times(1)).findByLastName(lastName, PageRequest.of(page - 1, PAGE_SIZE));
    }

    @Test
    void testFindPaginatedForOwnersLastName_InvalidLastName() {
        int page = 1;
        String lastName = ""; // TODO: Change the value to test other invalid inputs such as null or special characters

        when(owners.findByLastName(lastName, PageRequest.of(page - 1, PAGE_SIZE))).thenThrow(IllegalArgumentException.class);

        assertThrows(IllegalArgumentException.class, () -> ownerController.findPaginatedForOwnersLastName(page, lastName));

        verify(owners, times(1)).findByLastName(lastName, PageRequest.of(page - 1, PAGE_SIZE));
    }

    // Additional test cases can be added for scenarios such as:
    // - Boundary Page Number (First and Last Page)
    // - Invalid Page Number (Zero, Negative, Over Max)
    // - Page Size Consistency Across Pages
    // - Sorting Order
    // - Total Elements and Total Pages
    // - Search with Substring of Last Name
    // - Concurrency Handling
    // These would be similar in structure to the tests above, utilizing mocking and assertions to verify behavior.
}
