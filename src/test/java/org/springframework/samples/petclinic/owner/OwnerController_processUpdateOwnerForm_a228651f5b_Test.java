/*
Test generated by RoostGPT for test java-springboot-unit-testing using AI Type Open AI and AI Model gpt-4-1106-preview

To validate the business logic in the `processUpdateOwnerForm` method, you would need to write test scenarios that cover the expected behavior of the method. Here are some test scenarios that could be used to validate this method:

1. **Validation Success Scenario:**
   - Given a valid `Owner` object and an `ownerId`.
   - When the `processUpdateOwnerForm` method is called.
   - Then no validation errors should occur.
   - The `Owner` object's `id` should be set to the provided `ownerId`.
   - The `Owner` object should be saved using the `owners.save(owner)` method.
   - The method should return the correct redirect string "redirect:/owners/{ownerId}".

2. **Validation Failure Scenario:**
   - Given an `Owner` object with validation errors and an `ownerId`.
   - When the `processUpdateOwnerForm` method is called.
   - Then validation errors should be detected (`result.hasErrors()` returns `true`).
   - The method should return the view name for the owner create/update form without saving the `Owner` object.

3. **Owner ID Update Scenario:**
   - Given a valid `Owner` object with an initial `id` different from the `ownerId` path variable.
   - When the `processUpdateOwnerForm` method is called.
   - Then the `Owner` object's `id` should be updated to match the `ownerId` path variable before saving.

4. **Persistence Layer Interaction:**
   - Mock the `owners` repository to ensure that when `owners.save(owner)` is called, the `Owner` object is correctly passed to the persistence layer.
   - Verify that the `save` method on the mocked `owners` repository is called exactly once when there are no validation errors.

5. **Redirect Path Variable Substitution:**
   - Given a valid `Owner` object and an `ownerId` of 123.
   - When the `processUpdateOwnerForm` method is called.
   - Then the redirect string should include the correct path variable substitution, resulting in "redirect:/owners/123".

6. **BindingResult Error Handling:**
   - Given an `Owner` object with validation errors that populate the `BindingResult`.
   - When the `processUpdateOwnerForm` method is called.
   - Then the method should not attempt to save the `Owner` object and should return the correct view for re-entry.

7. **Owner ID Consistency:**
   - Given an `Owner` object and an `ownerId` that does not match the `Owner` object's `id`.
   - When the `processUpdateOwnerForm` method is called.
   - Then the `Owner` object's `id` should be overridden with the `ownerId` from the path variable before saving to ensure consistency.

8. **Negative Test - Invalid Owner ID:**
   - Given a valid `Owner` object and an invalid `ownerId` such as a negative number or zero.
   - When the `processUpdateOwnerForm` method is called.
   - Then the system should handle the situation gracefully, potentially validating the `ownerId` and returning an appropriate response or error message if necessary.

In a real-world scenario, one would also need to consider additional factors such as security, permissions, and transaction management. However, for the given code snippet and the scope of this question, the above test scenarios focus on the business logic validation and expected method outcomes.
*/
package org.springframework.samples.petclinic.owner;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.springframework.validation.BindingResult;
import static org.mockito.Mockito.*;
import static org.junit.jupiter.api.Assertions.*;

class OwnerController_processUpdateOwnerForm_a228651f5b_Test {

    @Mock
    private OwnerRepository owners;

    @Mock
    private BindingResult result;

    @InjectMocks
    private OwnerController ownerController;

    private static final String VIEWS_OWNER_CREATE_OR_UPDATE_FORM = "owners/createOrUpdateOwnerForm";

    @BeforeEach
    void setup() {
        MockitoAnnotations.openMocks(this);
    }

    @Test
    void testProcessUpdateOwnerFormSuccess() {
        Owner owner = new Owner();
        owner.setAddress("123 My Street");
        owner.setCity("MyCity");
        owner.setTelephone("1234567890");
        when(result.hasErrors()).thenReturn(false);

        String view = ownerController.processUpdateOwnerForm(owner, result, 1);

        verify(owners, times(1)).save(owner);
        assertEquals("redirect:/owners/1", view);
        assertEquals(1, owner.getId());
    }

    @Test
    void testProcessUpdateOwnerFormHasErrors() {
        Owner owner = new Owner();
        when(result.hasErrors()).thenReturn(true);

        String view = ownerController.processUpdateOwnerForm(owner, result, 1);

        verify(owners, never()).save(any(Owner.class));
        assertEquals(VIEWS_OWNER_CREATE_OR_UPDATE_FORM, view);
    }

    @Test
    void testProcessUpdateOwnerFormIdConsistency() {
        Owner owner = new Owner();
        owner.setId(999);
        when(result.hasErrors()).thenReturn(false);

        ownerController.processUpdateOwnerForm(owner, result, 1);

        verify(owners, times(1)).save(owner);
        assertEquals(1, owner.getId());
    }

    @Test
    void testProcessUpdateOwnerFormInvalidOwnerId() {
        Owner owner = new Owner();
        when(result.hasErrors()).thenReturn(false);

        Exception exception = assertThrows(IllegalArgumentException.class, () -> {
            ownerController.processUpdateOwnerForm(owner, result, -1);
        });

        String expectedMessage = "ID must not be negative";
        String actualMessage = exception.getMessage();

        assertTrue(actualMessage.contains(expectedMessage));
    }
}
