/*
Test generated by RoostGPT for test java-springboot-unit-testing using AI Type Open AI and AI Model gpt-4-1106-preview

To validate the business logic of the `initOwnerBinder` method, consider the following test scenarios:

1. **Disallowing 'id' field**:
   - Verify that the 'id' field is indeed disallowed. This means that if the 'id' field is provided in the binder, it should not be bound to the model object.
   - Attempt to bind an object that includes the 'id' field and ensure that the 'id' does not get populated or is ignored during the binding process.

2. **Allowing other fields**:
   - Confirm that fields other than 'id' are allowed and can be bound correctly. Provide a set of fields in the binder, including some other than 'id', and verify that they are correctly bound to the model object.

3. **Testing with different types of objects**:
   - Test the `initOwnerBinder` method with different types of model objects to ensure it consistently disallows the 'id' field across all of them.

4. **Handling of null or empty data binder**:
   - Pass a null `WebDataBinder` instance to the `initOwnerBinder` and verify how it is handled. The method should be able to handle such cases gracefully without throwing unexpected exceptions.
   - Pass an empty `WebDataBinder` instance (with no fields set) and verify that it does not throw any errors or exceptions.

5. **Testing the persistence of disallowed fields setting**:
   - After calling `initOwnerBinder`, ensure that the settings persist for the lifecycle of the `WebDataBinder` instance, meaning that 'id' remains disallowed for any subsequent operations until the binder is discarded or reset.

6. **Testing with complex object structures**:
   - If the model object contains nested objects or collections, verify that the 'id' field is disallowed for those nested objects as well.

7. **Integration with controller methods**:
   - In a scenario where `initOwnerBinder` is integrated with controller methods, ensure that when a form submits data to a controller, the 'id' field is not bound to the model even if it is present in the submission.

8. **Testing with different binding results**:
   - Verify that the `initOwnerBinder` method does not affect the `BindingResult` object that might be used in conjunction with the `WebDataBinder` in controller methods to handle validation and binding errors.

9. **Concurrency test**:
   - Ensure that when multiple requests are processed concurrently, the `initOwnerBinder` method works as expected and the 'id' field is disallowed in every case without side effects.

10. **Testing with custom editors or converters**:
    - If there are custom property editors or converters registered with the `WebDataBinder`, verify that the disallowing of the 'id' field does not interfere with their operation.

11. **Testing with programmatically added fields**:
    - If fields are added to the `WebDataBinder` programmatically after the `initOwnerBinder` method is called, verify that the 'id' field remains disallowed.

When designing the actual test cases, ensure that each scenario is clearly defined, and the assertions are specific to the behavior that is being tested. Moreover, make sure to consider both positive and negative test cases to cover the full breadth of possible interactions with the `initOwnerBinder` method.
*/
package org.springframework.samples.petclinic.owner;

import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertTrue;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.validation.BeanPropertyBindingResult;
import org.springframework.validation.BindingResult;
import org.springframework.web.bind.WebDataBinder;

public class PetController_initOwnerBinder_c48260f88f_Test {

    private PetController petController;
    private WebDataBinder dataBinder;

    @BeforeEach
    public void setup() {
        petController = new PetController(new OwnerRepository());
        dataBinder = new WebDataBinder(null);
    }

    @Test
    public void testDisallowIdField() {
        petController.initOwnerBinder(dataBinder);
        BindingResult bindingResult = new BeanPropertyBindingResult(new Object(), "target");
        
        dataBinder.bind(new MutablePropertyValues(Map.of("id", "1", "name", "Fido")));
        assertFalse(bindingResult.hasFieldErrors("id"), "Field 'id' should not be bound");
        assertTrue(bindingResult.hasFieldErrors("name"), "Field 'name' should be bound");
    }

    @Test
    public void testAllowOtherFields() {
        petController.initOwnerBinder(dataBinder);
        BindingResult bindingResult = new BeanPropertyBindingResult(new Object(), "target");

        dataBinder.bind(new MutablePropertyValues(Map.of("name", "Fido")));
        assertFalse(bindingResult.hasFieldErrors("name"), "Field 'name' should be bound");
    }

    @Test
    public void testHandlingNullDataBinder() {
        try {
            petController.initOwnerBinder(null);
        } catch (Exception e) {
            fail("initOwnerBinder should handle null WebDataBinder without throwing exceptions");
        }
    }

    @Test
    public void testPersistenceOfDisallowedFieldsSetting() {
        petController.initOwnerBinder(dataBinder);
        BindingResult bindingResult = new BeanPropertyBindingResult(new Object(), "target");

        dataBinder.bind(new MutablePropertyValues(Map.of("id", "1")));
        assertFalse(bindingResult.hasFieldErrors("id"), "Field 'id' should remain disallowed");
    }
}
