/*
Test generated by RoostGPT for test java-springboot-unit-testing using AI Type Open AI and AI Model gpt-4-1106-preview

To validate the business logic of the `processUpdateForm` method, you can create the following test scenarios:

1. **Pet Name Validation**
   - Scenario 1: Pet name is not provided (empty or null). The test should verify that a pet without a name does not trigger a validation error related to the name since the method does not explicitly reject empty names.
   - Scenario 2: Pet name is provided and is unique within the owner's collection of pets. The test should verify that no validation error is raised.
   - Scenario 3: Pet name is provided but not unique (another pet with the same name and different ID exists for the owner). The test should verify that a validation error is raised for the "name" field with the code "duplicate".

2. **Pet Birth Date Validation**
   - Scenario 4: Pet birth date is not provided (null). The test should verify that a pet without a birth date does not trigger a validation error related to the birth date.
   - Scenario 5: Pet birth date is provided and is in the past. The test should verify that no validation error is raised.
   - Scenario 6: Pet birth date is provided and is in the future. The test should verify that a validation error is raised for the "birthDate" field with the code "typeMismatch.birthDate".

3. **Binding Errors Handling**
   - Scenario 7: No binding errors are present. The test should verify that the pet is added to the owner and that the method returns the expected redirect string.
   - Scenario 8: There are binding errors present for fields other than "name" or "birthDate" (simulate a binding error). The test should verify that the pet is not added to the owner, the original pet is put back into the model, and the method returns the view for creating or updating a pet form.

4. **Owner and Pet Relationship**
   - Scenario 9: Verify that when there are no binding errors, the pet is correctly added to the owner's collection of pets.

5. **ModelMap Population**
   - Scenario 10: There are binding errors present. The test should verify that the model contains the correct attributes (e.g., the pet object) when the form is returned with errors.

6. **Persistence Invocation**
   - Scenario 11: Verify that when the pet is successfully added to the owner and there are no binding errors, the owner is saved (simulating the `owners.save(owner)` method call).

7. **Path Variable Consistency**
   - Scenario 12: Verify that the redirect URL contains the correct owner ID as a path variable.

For each scenario, you would typically create a corresponding test case in your test suite, mock dependencies as necessary (e.g., using a mocking framework such as Mockito), set up the required state, invoke the `processUpdateForm` method, and assert the expected outcomes.

Please note that the test scenarios above assume that the `processUpdateForm` method is part of a larger class with other methods such as `owners.save(owner)` which would need to be mocked or stubbed in the test cases.
*/
package org.springframework.samples.petclinic.owner;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

import java.time.LocalDate;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.ArgumentMatchers;
import org.springframework.ui.ModelMap;
import org.springframework.validation.BindingResult;
import org.springframework.validation.MapBindingResult;

public class PetController_processUpdateForm_8b32776c46_Test {
    private static final String VIEWS_PETS_CREATE_OR_UPDATE_FORM = "pets/createOrUpdatePetForm";

    private PetController petController;
    private OwnerRepository owners;
    private ModelMap model;
    private BindingResult result;
    private Owner owner;
    private Pet pet;

    @BeforeEach
    public void setup() {
        owners = mock(OwnerRepository.class);
        petController = new PetController(owners);
        model = new ModelMap();
        result = new MapBindingResult(model, "pet");
        owner = new Owner();
        pet = new Pet();
        pet.setId(1);
        owner.setId(1);
    }

    @Test
    public void testProcessUpdateForm_PetNameNotProvided() {
        pet.setName(null);
        
        String view = petController.processUpdateForm(pet, result, owner, model);
        
        assertEquals(VIEWS_PETS_CREATE_OR_UPDATE_FORM, view);
        assertEquals(pet, model.get("pet"));
    }

    @Test
    public void testProcessUpdateForm_PetNameUnique() {
        pet.setName("Buddy");
        
        String view = petController.processUpdateForm(pet, result, owner, model);
        
        assertEquals("redirect:/owners/{ownerId}", view);
        verify(owners).save(ArgumentMatchers.any());
    }

    @Test
    public void testProcessUpdateForm_PetNameNotUnique() {
        Pet anotherPet = new Pet();
        anotherPet.setName("Buddy");
        anotherPet.setId(2);
        List<Pet> pets = new ArrayList<>();
        pets.add(anotherPet);
        owner.setPetsInternal(pets);
        pet.setName("Buddy");
        
        petController.processUpdateForm(pet, result, owner, model);
        
        verify(result).rejectValue("name", "duplicate", "already exists");
    }

    @Test
    public void testProcessUpdateForm_BirthDateNotProvided() {
        pet.setBirthDate(null);
        
        String view = petController.processUpdateForm(pet, result, owner, model);
        
        assertEquals("redirect:/owners/{ownerId}", view);
        verify(owners).save(ArgumentMatchers.any());
    }

    @Test
    public void testProcessUpdateForm_BirthDateInPast() {
        pet.setBirthDate(LocalDate.of(2010, 1, 1));
        
        String view = petController.processUpdateForm(pet, result, owner, model);
        
        assertEquals("redirect:/owners/{ownerId}", view);
        verify(owners).save(ArgumentMatchers.any());
    }

    @Test
    public void testProcessUpdateForm_BirthDateInFuture() {
        pet.setBirthDate(LocalDate.now().plusDays(1));
        
        petController.processUpdateForm(pet, result, owner, model);
        
        verify(result).rejectValue("birthDate", "typeMismatch.birthDate");
    }

    @Test
    public void testProcessUpdateForm_NoBindingErrors() {
        String view = petController.processUpdateForm(pet, result, owner, model);
        
        assertEquals("redirect:/owners/{ownerId}", view);
        verify(owners).save(owner);
    }

    @Test
    public void testProcessUpdateForm_BindingErrorsPresent() {
        result.reject("error");
        
        String view = petController.processUpdateForm(pet, result, owner, model);
        
        assertEquals(VIEWS_PETS_CREATE_OR_UPDATE_FORM, view);
        assertEquals(pet, model.get("pet"));
    }

    @Test
    public void testProcessUpdateForm_PetAddedToOwner() {
        petController.processUpdateForm(pet, result, owner, model);
        
        assertEquals(1, owner.getPets().size());
        assertEquals(pet, owner.getPets().get(0));
    }

    @Test
    public void testProcessUpdateForm_ModelMapPopulationWithErrors() {
        result.reject("error");
        
        petController.processUpdateForm(pet, result, owner, model);
        
        assertEquals(pet, model.get("pet"));
    }

    @Test
    public void testProcessUpdateForm_PersistenceInvocation() {
        petController.processUpdateForm(pet, result, owner, model);
        
        verify(owners).save(owner);
    }

    @Test
    public void testProcessUpdateForm_PathVariableConsistency() {
        when(owner.getId()).thenReturn(1);
        
        String view = petController.processUpdateForm(pet, result, owner, model);
        
        assertEquals("redirect:/owners/1", view);
    }
}
