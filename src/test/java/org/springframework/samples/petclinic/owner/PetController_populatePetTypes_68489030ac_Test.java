/*
Test generated by RoostGPT for test pom-test using AI Type Open AI and AI Model gpt-4

1. Scenario: Check if the function returns all pet types.
   - Create several pet types in the database.
   - Run populatePetTypes and check if it returns all pet types.

2. Scenario: Check if the function returns an empty collection when there are no pet types.
   - Ensure there are no pet types in the database.
   - Run populatePetTypes and verify that it returns an empty collection.

3. Scenario: Check if the function handles null values properly.
   - Insert null values into the database.
   - Run populatePetTypes and verify that it does not return null values.

4. Scenario: Check if the function handles duplicate pet types correctly.
   - Create several duplicate pet types in the database.
   - Run populatePetTypes and check if it returns a collection with no duplicates.

5. Scenario: Check if the function handles mixed cases correctly.
   - Create several pet types in the database with mixed case (upper, lower).
   - Run populatePetTypes and check if it returns the expected pet types, regardless of case.

6. Scenario: Check if the function handles special characters in pet types.
   - Create several pet types in the database with special characters.
   - Run populatePetTypes and verify that it returns the pet types correctly, including special characters.

7. Scenario: Check the function's performance with a large number of pet types.
   - Create a large number of pet types in the database.
   - Run populatePetTypes and verify that it returns the correct pet types without significant delay.

8. Scenario: Check if the function is thread-safe.
   - Run populatePetTypes from multiple threads simultaneously and verify that it returns the correct pet types.

9. Scenario: Check if the function handles database connection issues.
   - Simulate a database connection failure while running populatePetTypes.
   - Verify that the function handles the failure gracefully, without crashing or hanging. 

10. Scenario: Check if the function handles transaction rollbacks correctly.
    - Create a scenario where a transaction needs to be rolled back while running populatePetTypes.
    - Verify that the function handles the rollback correctly, without any data inconsistencies.
*/
package org.springframework.samples.petclinic.owner;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;

import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.mockito.Mockito.*;

public class PetController_populatePetTypes_68489030ac_Test {

    @Mock
    private OwnerRepository owners;

    @InjectMocks
    private PetController petController;

    @BeforeEach
    public void init() {
        MockitoAnnotations.initMocks(this);
    }

    @Test
    public void testPopulatePetTypes() {
        PetType dog = new PetType();
        dog.setName("Dog");
        PetType cat = new PetType();
        cat.setName("Cat");

        when(owners.findPetTypes()).thenReturn(Arrays.asList(dog, cat));

        Collection<PetType> petTypes = petController.populatePetTypes();

        assertEquals(2, petTypes.size());
        assertTrue(petTypes.containsAll(Arrays.asList(dog, cat)));
    }

    @Test
    public void testPopulatePetTypesEmpty() {
        when(owners.findPetTypes()).thenReturn(Collections.emptyList());

        Collection<PetType> petTypes = petController.populatePetTypes();

        assertTrue(petTypes.isEmpty());
    }

    @Test
    public void testPopulatePetTypesNull() {
        when(owners.findPetTypes()).thenReturn(null);

        Collection<PetType> petTypes = petController.populatePetTypes();

        assertTrue(petTypes.isEmpty());
    }

}
