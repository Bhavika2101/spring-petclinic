/*
Test generated by RoostGPT for test java-springboot-unit-testing using AI Type Open AI and AI Model gpt-4-1106-preview

To validate the business logic of the `parse` method, the following test scenarios can be considered:

1. **Valid Pet Type Name**:
   - Scenario: Input text matches a pet type name in the collection.
   - Expected Result: The `parse` method should return the matching `PetType` object.

2. **Invalid Pet Type Name**:
   - Scenario: Input text does not match any pet type name in the collection.
   - Expected Result: The `parse` method should throw a `ParseException` with the message including "type not found" and the input text.

3. **Case Sensitivity**:
   - Scenario: Input text matches a pet type name in the collection but has different case sensitivity.
   - Expected Result: Depending on business rules, either a case-sensitive match is required and a `ParseException` is thrown, or a case-insensitive match is acceptable and the correct `PetType` object is returned.

4. **Empty String Input**:
   - Scenario: The input text is an empty string.
   - Expected Result: The method should throw a `ParseException` because an empty string does not correspond to any pet type.

5. **Null Input**:
   - Scenario: The input text is `null`.
   - Expected Result: The behavior is not defined in the snippet, but typically a `NullPointerException` or a `ParseException` should be thrown.

6. **Whitespace Input**:
   - Scenario: The input text contains only whitespace.
   - Expected Result: The method should throw a `ParseException` as whitespace is unlikely to match a pet type name.

7. **Locale Variation**:
   - Scenario: The input text is valid in one locale but invalid in another.
   - Expected Result: Since the current implementation does not use the `locale` parameter, the result should be the same regardless of the locale value. However, this could be a point of extension for multi-lingual support.

8. **Collection with Duplicate Pet Types**:
   - Scenario: The collection `findPetTypes` contains duplicate `PetType` names.
   - Expected Result: The method should return the first `PetType` object in the collection that matches the input text.

9. **Empty Collection**:
   - Scenario: The collection `findPetTypes` is empty.
   - Expected Result: The method should always throw a `ParseException` because there are no types to match.

10. **Special Characters in Input**:
    - Scenario: The input text contains special characters or punctuation.
    - Expected Result: If special characters are not expected in pet type names, the method should throw a `ParseException`.

11. **Numeric Input**:
    - Scenario: The input text is numeric.
    - Expected Result: Unless numeric values are valid pet type names, the method should throw a `ParseException`.

12. **Internationalization and Localization (i18n and L10n)**:
    - Scenario: The input text contains characters that are specific to a locale (e.g., accented characters).
    - Expected Result: Since the locale is not used in the current implementation, the method should either throw a `ParseException` if the text does not match, or return the correct `PetType` if it does, regardless of locale-specific characters.

13. **Performance with Large Collection**:
    - Scenario: The collection `findPetTypes` is very large.
    - Expected Result: The method should still perform efficiently and return results within acceptable time bounds.

14. **Concurrency**:
    - Scenario: Multiple threads are calling the `parse` method simultaneously with different inputs.
    - Expected Result: The method should handle concurrent access gracefully and return the correct results for each thread without any data corruption or race conditions.

Each of these scenarios would need to be translated into actual test cases in a testing framework. The test cases should include assertions to verify that the expected results are obtained for each scenario.
*/
package org.springframework.samples.petclinic.owner;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import java.text.ParseException;
import java.util.ArrayList;
import java.util.List;
import java.util.Locale;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.when;

@ExtendWith(MockitoExtension.class)
public class PetTypeFormatter_parse_2ffcaf4072_Test {

    @Mock
    private OwnerRepository owners;

    private PetTypeFormatter petTypeFormatter;

    @BeforeEach
    public void setUp() {
        petTypeFormatter = new PetTypeFormatter(owners);
    }

    @Test
    public void testParse_ValidPetTypeName() throws ParseException {
        // Arrange
        String inputText = "Dog";
        PetType petType = new PetType();
        petType.setName(inputText);
        List<PetType> petTypes = new ArrayList<>();
        petTypes.add(petType);
        when(owners.findPetTypes()).thenReturn(petTypes);

        // Act
        PetType result = petTypeFormatter.parse(inputText, Locale.ENGLISH);

        // Assert
        assertEquals(petType, result);
    }

    @Test
    public void testParse_InvalidPetTypeName() {
        // Arrange
        String inputText = "Dragon";
        when(owners.findPetTypes()).thenReturn(new ArrayList<>());

        // Act & Assert
        ParseException exception = assertThrows(ParseException.class, () -> {
            petTypeFormatter.parse(inputText, Locale.ENGLISH);
        });

        // Assert
        assertTrue(exception.getMessage().contains("type not found: " + inputText));
    }

    @Test
    public void testParse_EmptyStringInput() {
        // Arrange
        String inputText = "";
        when(owners.findPetTypes()).thenReturn(new ArrayList<>());

        // Act & Assert
        ParseException exception = assertThrows(ParseException.class, () -> {
            petTypeFormatter.parse(inputText, Locale.ENGLISH);
        });

        // Assert
        assertTrue(exception.getMessage().contains("type not found: " + inputText));
    }

    @Test
    public void testParse_NullInput() {
        // Arrange
        String inputText = null;
        when(owners.findPetTypes()).thenReturn(new ArrayList<>());

        // Act & Assert
        assertThrows(NullPointerException.class, () -> {
            petTypeFormatter.parse(inputText, Locale.ENGLISH);
        });
    }

    @Test
    public void testParse_WhitespaceInput() {
        // Arrange
        String inputText = " ";
        when(owners.findPetTypes()).thenReturn(new ArrayList<>());

        // Act & Assert
        ParseException exception = assertThrows(ParseException.class, () -> {
            petTypeFormatter.parse(inputText, Locale.ENGLISH);
        });

        // Assert
        assertTrue(exception.getMessage().contains("type not found: " + inputText.trim()));
    }

    // TODO: Additional test cases can be implemented here, following the scenarios provided.
}
